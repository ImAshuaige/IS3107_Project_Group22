# -*- coding: utf-8 -*-
"""IS3107Proj_EDA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uwXYzO5hGzVC_7IzqLzydnUFaIweI7Ve
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Connect your Google Drive to your Colab file
from google.colab import drive
drive.mount('/content/drive')

bitcoinPrice = pd.read_csv('/content/drive/MyDrive/IS3107/bitcoin.csv')
print(bitcoinPrice.head())

# Checking dataframe dimensionality
print("The dimension of this dataset: ", bitcoinPrice.shape, "\n")

print(bitcoinPrice.tail(5))

print("Type of variables:", "\n", bitcoinPrice.dtypes)

f, axes = plt.subplots(1, 3, figsize=(15, 5), sharex=False, sharey=False)
axes = axes.ravel()
i = 0

# List of features to plot
features_to_plot = ['price', 'total_volume', 'market_cap']

for feature in features_to_plot:
    if bitcoinPrice[feature].dtype == "float64":
        sns.histplot(bitcoinPrice, x=feature, kde=True, stat='density', ax=axes[i])
    else:
        sns.histplot(bitcoinPrice, x=feature, ax=axes[i])
    i += 1

f.tight_layout()
plt.show()

print(bitcoinPrice.isnull().sum())
print("===================================")
print(bitcoinPrice.isnull().any())

# Convert the 'date' column to a datetime object
bitcoinPrice['date'] = pd.to_datetime(bitcoinPrice['date'])

# Create a single figure
plt.figure(figsize=(15, 10))

# Violin plots for outlier detection
features_to_plot = ['price', 'total_volume', 'market_cap']
for i, feature in enumerate(features_to_plot):
    plt.subplot(2, 3, i + 1)
    sns.violinplot(data=bitcoinPrice, y=feature)
    plt.title(f'Violin plot of {feature}')

# Scatter plots for relationships between features
scatter_features = ['price', 'total_volume', 'market_cap']
sns.pairplot(data=bitcoinPrice, vars=scatter_features)
plt.show()

# Adjust the layout and display the plot
plt.tight_layout()
plt.show()

# Scatter plots for relationships between features
scatter_features = ['price', 'total_volume', 'market_cap']
sns.pairplot(data=bitcoinPrice, vars=scatter_features)
plt.show()

import matplotlib.pyplot as plt

# Extracting the data
dates = bitcoinPrice['date']
prices = bitcoinPrice['price']

# Plotting the data
plt.plot(dates, prices)

# Adding titles and labels
plt.title('Bitcoin Price Over Time')
plt.xlabel('Date')
plt.ylabel('Price')

# Displaying the plot
plt.show()

dates = bitcoinPrice['date']
prices = bitcoinPrice['price']
volumes = bitcoinPrice['total_volume']
market_cap = bitcoinPrice['market_cap']

# Creating a 3-row, 1-column grid of subplots
fig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(10, 15))

# Plotting the first graph (Bitcoin Volume Over Time)
ax1.plot(dates, prices)
ax1.set_title('Bitcoin Price Over Time')
ax1.set_xlabel('Date')
ax1.set_ylabel('Price')

# Plotting the second graph (Total Volume of Bitcoins Over Time)
ax2.stackplot(dates, volumes, labels=['Bitcoin'])
# ... add more volumes and corresponding labels if needed
ax2.set_title('Total Volume of Bitcoins Over Time')
ax2.set_xlabel('Date')
ax2.set_ylabel('Volume')
ax2.legend(loc='upper left')

# Plotting the third graph (Market Capitalization Over Time)
ax3.plot(dates, market_cap)
ax3.set_title('Market Capitalization Over Time')
ax3.set_xlabel('Date')
ax3.set_ylabel('Market Cap')

# Adjusting space between the plots
plt.subplots_adjust(hspace=0.5)

# Displaying the combined plot
plt.show()

bitcoinTweets = pd.read_csv('/content/drive/MyDrive/IS3107/Finalised_Sentiments.csv')
print(bitcoinTweets.head())
print("Type of variables:", "\n", bitcoinTweets.dtypes)

# Checking dataframe dimensionality
print("The dimension of this dataset: ", bitcoinTweets.shape, "\n")

print("Type of variables:", "\n", bitcoinTweets.dtypes)

# Convert the 'date' column to a datetime object
bitcoinTweets['date'] = pd.to_datetime(bitcoinTweets['date'])

# Group the data by 'date' and sum the sentiment scores
grouped_bitcoinTweets = bitcoinTweets.groupby('date').agg({'negative': 'sum', 'neutral': 'sum', 'positive': 'sum', 'compound': 'sum'}).reset_index()

# Plot the sentiment scores with different colors
plt.figure(figsize=(12, 6))
plt.plot(grouped_bitcoinTweets['date'], grouped_bitcoinTweets['negative'], color='red', label='Negative')
plt.plot(grouped_bitcoinTweets['date'], grouped_bitcoinTweets['neutral'], color='orange', label='Neutral')
plt.plot(grouped_bitcoinTweets['date'], grouped_bitcoinTweets['positive'], color='green', label='Positive')
plt.plot(grouped_bitcoinTweets['date'], grouped_bitcoinTweets['compound'], color='blue', label='Compound')

plt.xlabel('Date')
plt.ylabel('Sentiment Scores')
plt.title('Sentiment Scores Grouped by Dates')
plt.legend()
plt.show()

# Convert the 'date' columns to datetime objects
bitcoinTweets['date'] = pd.to_datetime(bitcoinTweets['date'])
bitcoinPrice['date'] = pd.to_datetime(bitcoinPrice['date'])

# Merge the two DataFrames on the 'date' column
merged_df = pd.merge(bitcoinTweets, bitcoinPrice, on='date', how='inner')

# Group the merged DataFrame by 'date' and sum the sentiment scores
grouped_merged_df = merged_df.groupby('date').agg({'negative': 'sum', 'neutral': 'sum', 'positive': 'sum', 'compound': 'sum', 'price': 'mean'}).reset_index()

# Calculate the correlation between the 'compound' column and the 'price' column
correlation = grouped_merged_df['compound'].corr(grouped_merged_df['price'])
print(f"Correlation between compound sentiment scores and bitcoin price: {correlation}")

# Create a scatter plot with a linear regression line to visualize the correlation
sns.regplot(x='compound', y='price', data=grouped_merged_df)
plt.xlabel('Compound Sentiment Score')
plt.ylabel('Bitcoin Price')
plt.title('Correlation between Compound Sentiment Score and Bitcoin Price')

# Add the correlation score to the graph
plt.text(0.05, 0.95, f'Correlation: {correlation:.2f}', transform=plt.gca().transAxes, fontsize=12, verticalalignment='top', bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))

plt.show()